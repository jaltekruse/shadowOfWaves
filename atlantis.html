<!--
 This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<html>
<title> MHacks RTS </title>
<head> 
	<script type="text/javascript" src="Globals.js"></script>
	<script type="text/javascript" src="WorldObjects.js"></script>
	<script type="text/javascript" src="GridStorage.js"></script>
<script type="text/javascript">


(function() {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelRequestAnimationFrame = window[vendors[x]+
          'CancelRequestAnimationFrame'];
    } 
    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
              timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
}())

function set_size() {
	if (document.body && document.body.offsetWidth) {
	 winW = document.body.offsetWidth;
	 winH = document.body.offsetHeight;
	}
	if (document.compatMode=='CSS1Compat' &&
		document.documentElement &&
		document.documentElement.offsetWidth ) {
		winW = document.documentElement.offsetWidth;
		winH = document.documentElement.offsetHeight;
	}
	if (window.innerWidth && window.innerHeight) {
		winW = window.innerWidth;
		winH = window.innerHeight;
	}
	screen_size.x = winW - 30;
	screen_size.y = winH - 30;
	
	document.getElementById("game_canvas").setAttribute("width", screen_size.x);
	document.getElementById("game_canvas").setAttribute("height", screen_size.y);
}

function Game(){
	this.players = new Array();
	this.time = 0;
}

function mouse_up(evt){
	p.selection.x = -1;
	p.selection.y = -1;
	p.selection.w = 1;
	p.selection.h = 1;
	p.selection_status.x = -10;
	p.selection_status.y = -10;
}

function mouse_down(evt){
	x = evt.offsetX?(evt.offsetX):evt.pageX-document.getElementById("game_canvas").offsetLeft;
	y = evt.offsetY?(evt.offsetY):evt.pageY-document.getElementById("game_canvas").offsetTop;
	p.selection.x = x + p.origin.x;
	p.selection.y = y + p.origin.y;
}

function key_down(){

}

function mouse_scroll(evt){

}

function mouse_move(evt){
	x = evt.offsetX?(evt.offsetX):evt.pageX-document.getElementById("game_canvas").offsetLeft;
	y = evt.offsetY?(evt.offsetY):evt.pageY-document.getElementById("game_canvas").offsetTop;
	p.mouse_pos.x = x;
	p.mouse_pos.y = y;

	// adjust the selection rectangle
	var s =	p.selection;
	if ( Math.abs(p.selection_status.x) != 1)
	{// first time the mouse is moving after the mouse was pressed
		if ( x + p.origin.x < s.x )
			p.selection_status.x = -1;
		else
			p.selection_status.x = 1;
		if ( y + p.origin.y < s.y )
			p.selection_status.y = -1;
		else
			p.selection_status.y = 1;
	}
	if ( s.x > 0 && s.y > 0){
		if (p.selection_status.x == 1){
			s.w = x + p.origin.x - s.x;
		}
		else{
			s.w += s.x - (x + p.origin.x);
			s.x = x + p.origin.x;
		}
		if (p.selection_status.y == 1){
			s.h = y + p.origin.y - s.y;
		}
		else{
			s.h += s.y - (y + p.origin.y);
			s.y = y + p.origin.y;
		}
		
	}
	if ( s.w < 0 ){
		s.x = s.x + s.w;
		s.w = Math.abs(s.w);
		p.selection_status.x *= -1;
	}
	if ( s.h < 0 ){
		s.y = s.y + s.h;
		s.h = Math.abs(s.h);
		p.selection_status.y *= -1;
	}

	// update selected units
	if ( s.x > 0 && s.y > 0){
		for (var j = 0; j < p.units.length; j++){
			p.units[j].selected = false;
			if ( intersectRect(p.units[j].collision_rect(), p.selection) ){
				p.units[j].selected = true;
			}
		}
	}
}

function initialize_water_world() {
	var test_canvas = document.createElement("canvas"); //try and create sample canvas element
	var canvascheck=(test_canvas.getContext)? true : false;
	if( canvascheck == true){
			document.getElementById("header_span").innerHTML = "<canvas onmouseup=\"mouse_up(event)\" " + 
			"onmousemove=\"mouse_move(event)\" onmousedown=\"mouse_down(event)\" id=\"game_canvas\" width=\"1000\" height=\"600\"></canvas>";
	}
	else{
		document.getElementById("header_span").innerHTML = "<h2>Hello There</h2>";
	}
	
	set_size();
	
	thisGame = new Game();
	thisGame.players.push(new Player(0, 0, "rgb(255, 0, 0)"));
	thisGame.players.push(new Player(0, 0, "rgb(0, 255, 0)"));
	
	p = thisGame.players[currPlayer];

	p.mouse_pos.x = screen_size.x / 2; 
	p.mouse_pos.y = screen_size.y / 2; 

	thisGame.players[0].units.push(new Unit(70, 50, 5, GROUND, WORKER, GATHERER, thisGame.players[0]));
	thisGame.players[0].units.push(new Unit(30, 80, 5, GROUND, WORKER, GATHERER, thisGame.players[0]));
	thisGame.players[1].units.push(new Unit(200, 50, 5, GROUND, WORKER, GATHERER, thisGame.players[1]));
	var pos_x = 0, pos_y = 0, player = 0;
	for (var i = 0; i < 500; i++) {
		pos_x = randomInt(0, map_size.x);
		pos_y = randomInt(0, map_size.y);
		player = randomInt(0, thisGame.players.length);
		thisGame.players[player].units.push(new Unit(pos_x, pos_y, 10, GROUND, WORKER, GATHERER, thisGame.players[player]));
	}
	timer = setTimeout("frame()", frame_rate * 10);
}


function randomInt(a, b) {
	return Math.floor((Math.random() * b)) + a; 
}

function frame(){
	
	for (var i = 0; i < thisGame.players.length; i++){
		for (var j = 0; j < thisGame.players[i].units.length; j++){
			thisGame.players[i].units[j].update();
		}
	}

	// Update view 
	var speed = 20;
	var movement_boarder = .15;
	var left_movement_border = movement_boarder * screen_size.x;
	var mp = p.mouse_pos;
	var origin = p.origin;
	if (mp.x < left_movement_border && origin.x > 0) {
		origin.x -= speed * (left_movement_border - mp.x)/left_movement_border;
	}
	var right_movement_border = screen_size.x - movement_boarder * screen_size.x;
	if (mp.x > right_movement_border && origin.x + screen_size.x < map_size.x) {
		origin.x += speed * (mp.x - right_movement_border)/(screen_size.x - right_movement_border);
	}
	var top_movement_border = movement_boarder * screen_size.y;
	if (mp.y < top_movement_border && origin.y > 0) {
		origin.y -= speed * (top_movement_border - mp.y)/top_movement_border;
	}
	var bottom_movement_border = screen_size.y - movement_boarder * screen_size.y;
	if (mp.y > bottom_movement_border && origin.y + screen_size.y < map_size.y ) {
		origin.y += speed * (mp.y - bottom_movement_border)/(screen_size.y - bottom_movement_border);
	}

	// snap to edge map
	if (origin.y < 0) origin.y = 0;
	if (origin.y > map_size.y) origin.y = map_size.y - screen_size.y;
	if (origin.x < 0) origin.x = 0;
	if (origin.x > map_size.x) origin.x = map_size.x - screen_size.x;

	draw_world();

	window.requestAnimationFrame(frame);
}

function intersectRect(r1, r2) {
  return !(r2.x > r1.x + r1.w || 
           r2.w + r2.x < r1.x || 
           r2.y > r1.y + r1.h ||
           r2.y + r2.h  < r1.y);
}

function draw_world(){
	var canvas = document.getElementById("game_canvas");
	if (canvas.getContext) {
		ctx = canvas.getContext("2d");	

		ctx.fillStyle = "rgb(230, 230, 255)";
		ctx.fillRect(0,0, screen_size.x, screen_size.y);

		for (var i = 0; i < thisGame.players.length; i++){
			for (var j = 0; j < thisGame.players[i].units.length; j++){
				thisGame.players[i].units[j].draw(ctx, thisGame, p);
			}
		}
		draw_selection(ctx);
	}
	ctx.fillText("sel: " + p.selection.x + ", " + p.selection.y + ", " + p.selection.w + ", " + p.selection.h, 30, 500);
}

function draw_selection(ctx){
	var s =	p.selection;
	if ( s.x < 0 || s.y < 0){
		return
	}
	ctx.strokeStyle = "rgb(0, 0, 0)";
	ctx.strokeRect( s.x - p.origin.x , s.y - p.origin.y, s.w, s.h);
}

function page_load() {
	var mousewheelevt=(/Firefox/i.test(navigator.userAgent))? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of FF3.x
		 
	if (document.attachEvent) //if IE (and Opera depending on user setting)
		document.attachEvent("on"+mousewheelevt, function(e) {mouse_scroll(e)}, false);
	else if (document.addEventListener) //WC3 browsers
		document.addEventListener(mousewheelevt, function(e) {mouse_scroll(e)}, false);
	initialize_water_world();
}

</script>      
</head>
<body style="overflow: hidden"  onload="page_load()" onkeydown="key_down(event)">
<span id="header_span"> </span>
</body>
</html>
